#!/usr/bin/env python3
import subprocess
import argparse
from pathlib import Path
from termcolor import colored
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
import re
import sys
import signal
import random

COLORS = {
    'banner': 'cyan',
    'url': 'yellow',
    'vulnerable': 'green',
    'critical': 'red',
    'warning': 'yellow',
    'info': 'blue',
    'sql': 'magenta',
    'parameter': 'cyan',
    'dbms': 'yellow',
    'technique': 'green',
    'payload': 'white'
}


def show_banner():
    banner = rf"""
   ____ ____ __  __    _    ____  
  / ___/ ___||  \/  |  / \  | __ ) 
 | |   \___ \| |\/| | / _ \ |  _ \ 
 | |___ ___) | |  | |/ ___ \| |_) |
  \____|____/|_|  |_/_/   \_\____/ 

       ‚ö°  c3mab  ‚ö°
  Advanced SQL Injection Framework
"""
    print(colored(banner, COLORS['banner'], attrs=["bold"]))
    print(colored(f"üî∞ c3mab Team | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n", COLORS['info']))


def colorize_output(line):
    """Enhanced output coloring with SQL injection type detection"""
    line = line.strip()
    
    
    if any(x in line.lower() for x in ['vulnerable', 'injectable']):
        if 'boolean-based' in line.lower():
            tech = colored("BOOLEAN-BASED", COLORS['technique'])
        elif 'time-based' in line.lower():
            tech = colored("TIME-BASED", COLORS['technique'])
        elif 'error-based' in line.lower():
            tech = colored("ERROR-BASED", COLORS['technique'])
        elif 'union' in line.lower():
            tech = colored("UNION", COLORS['technique'])
        else:
            tech = colored("SQLi", COLORS['technique'])
            
        return colored(f"[üíâ VULN] {tech} - {line}", COLORS['vulnerable'])
    
    
    elif any(x in line.lower() for x in ['dbms', 'database', 'mysql', 'postgresql']):
        return colored(f"[üõ¢Ô∏è DB] {line}", COLORS['dbms'])
    
    
    elif 'payload:' in line.lower():
        return colored(f"[‚ö° PAYLOAD] {line}", COLORS['payload'])
    
    
    elif 'parameter' in line.lower():
        return colored(f"[üéØ PARAM] {line}", COLORS['parameter'])
    
    
    elif any(x in line for x in ['WARNING', 'CAUTION']):
        return colored(f"[‚ö†Ô∏è WARN] {line}", COLORS['warning'])
    
    
    elif any(x in line for x in ['CRITICAL', 'ERROR']):
        return colored(f"[‚ò†Ô∏è CRIT] {line}", COLORS['critical'])
    
    
    elif line.startswith('__') or 'sqlmap' in line.lower():
        return colored(f"[‚ö° SQLMAP] {line}", COLORS['sql'])
    
    
    elif any(x in line for x in ['INFO', 'testing']):
        return colored(f"[‚ÑπÔ∏è INFO] {line}", COLORS['info'])
    
    
    return colored(f"[‚ö°] {line}", 'white')


def run_elite_scan(target, args):
    try:
        print(colored(f"\n[üéØ] TARGET: {target}", COLORS['url'], attrs=['bold']))
        
        cmd = [
            "sqlmap",
            "-u", target,
            "--batch",
            "--output-dir=logs",
            f"--level={args.level}",
            f"--risk={args.risk}",
            "--answers=continue=Y,using=N,unionChar=Y"
        ]

        if args.stealth:
            cmd.extend(["--delay=2", "--tamper=between,randomcase"])
        
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1
        )

        vulns = []
        while True:
            line = process.stdout.readline()
            if not line and process.poll() is not None:
                break
            
            
            colored_line = colorize_output(line)
            print(colored_line)
            
            
            if any(x in line.lower() for x in ['vulnerable', 'injectable']):
                vulns.append(line.strip())

        return {
            'target': target,
            'vulnerabilities': vulns,
            'status': 'success'
        }

    except Exception as e:
        return {
            'target': target,
            'error': str(e),
            'status': 'failed'
        }


if __name__ == "__main__":
    signal.signal(signal.SIGINT, lambda x,y: sys.exit(0))
    show_banner()

    parser = argparse.ArgumentParser(description="üî• ELITE SQL Injection Scanner")
    parser.add_argument("-u", "--url", help="Target URL")
    parser.add_argument("-f", "--file", help="File containing URLs")
    parser.add_argument("--level", type=int, choices=range(1,6), default=3)
    parser.add_argument("--risk", type=int, choices=range(1,4), default=2)
    parser.add_argument("--stealth", action="store_true", help="Enable stealth mode")
    parser.add_argument("--threads", type=int, default=3)
    args = parser.parse_args()

    
    targets = []
    if args.url:
        targets.append(args.url)
    elif args.file:
        with open(args.file) as f:
            targets = [line.strip() for line in f if line.strip()]
    
    if not targets:
        print(colored("[!] No targets specified", COLORS['warning']))
        sys.exit(1)

    
    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = {executor.submit(run_elite_scan, target, args): target for target in targets}
        
        for future in as_completed(futures):
            target = futures[future]
            try:
                result = future.result()
                if result['status'] == 'success':
                    print(colored(f"\n[‚úî] Scan completed for {target}", COLORS['vulnerable']))
                    for vuln in result['vulnerabilities']:
                        print(colored(f"  ‚Üí {vuln}", COLORS['technique']))
            except Exception as e:
                print(colored(f"\n[‚úñ] Scan failed for {target}: {e}", COLORS['critical']))

    print(colored("\n[üéØ] Scan complete!", COLORS['banner'], attrs=['bold']))
